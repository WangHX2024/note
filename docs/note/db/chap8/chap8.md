# Chapter 8: Indexing and Hashing

## 一、基本概念

1. **索引条目（Index Entries）的基本内容**

![image.png](image.png)

1. **索引的基本类型**
    - 顺序索引（Ordered Index）：search-key 按顺序存储
    - 散列索引（Hash Index）：借助 hash function，search-key 在若干个 数据桶（bucket）之间均匀分布
2. **索引性能的衡量**
    - Access / Insertion / Deletion Time
    - Space Overhead（空间开销）

## 二、顺序索引

1. 在顺序索引中，索引条目按 search-key 的排序顺序存储
2. 顺序排序文件（Sequentially Ordered File）：文件中的记录按 search-key 的排序顺序存储
3. 索引顺序文件（Indexed Sequential File）：包含主索引的顺序排序文件

### 1. 主索引与辅助索引

1. **主索引（Primary Index）：**与对应的数据文件本身的排列顺序相同的索引
    - 别名：聚集索引（Clustering Index）
    - 主索引的 search-key 通常是主键，但不一定是主键
2. **辅助索引（Secondary Index）：**与对应的数据文件本身的排列顺序不同的索引
    - 别名：非聚集索引（Non-Clustering Index）
    - 意义：当对非主键的其它属性进行查询时，辅助索引可以避免全表扫描
    - 辅助索引不能使用稀疏索引，每条记录都必须有指针指向
    - 为解决重复项的问题，使用 bucket 结构：每个 search-key 都指向一个 bucket，该 bucket 包含指向具有该特定 search-key 值的所有实际记录的指针
    - bucket 结构的替代方案：在 search-key 中加入一个 record-identifier，从而使 search-key 唯一
    
    !!! example

        > **示例：**为 balance 建立辅助索引，使用 bucket 结构解决重复项问题
        > 
        > 
        > ![image.png](image%201.png)
        > 

3. **多级索引（Multilevel Index）**
    - 意义：解决主索引太大，无法在 Memory 中被容纳的问题
    - 多级索引技术既可用于稠密索引，也可用于稀疏索引
    - 分为内层（Inner Index）和外层（Outer Index），其中外层索引是内层索引的稀疏索引
        
        ![image.png](image%202.png)
        

### 2. 稠密索引与稀疏索引

1. **稠密索引（Dence Index）：**为 search-key 的每个值都建立对应的索引条目
    
    !!! example

        > **示例：**
        > 
        > - 下图为 id 的每个值都建立对应的索引条目，故为稠密索引
        >     
        >     ![image.png](image%203.png)
        >     
        > - 下图为 department 的每个值都建立了对应的索引条目，虽然并未对每个元组都建立对应的索引条目，但它符合稠密索引的定义，故为稠密索引
        >     
        >     ![image.png](image%204.png)
        >     

2. **稀疏索引（Sparse Index）：**只为 search-key 的部分值建立对应的索引条目
    - 通常，为每个数据块（block）建立一条索引
    - 稀疏索引依赖于数据的有序性，只能用于顺序文件；而稠密索引可以用于顺序和非顺序文件
    
    !!! example

        > **示例：**
        > 
        > 
        > ![image.png](image%205.png)
        > 

### 3. B+ 树索引

1. **B+ 树基本知识**
    - B+ 树是平衡树，从根到叶子的所有路径等长
    - 每个既非根又非叶子的节点具有 $\lceil n/2\rceil$ 至 $n$ 个儿子
    - 若叶子节点不是根节点，则叶子节点具有 $\lceil (n-1)/2\rceil$ 至 $(n-1)$ 个值
    - 若叶子节点是根节点，则该节点具有 0 至 $(n-1)$ 个值
    - 设 B+ 树的度为 $n$，包含 $K$ 个 search-key 值，则树高不大于 $\lceil log_{\lceil n/2\rceil}(K)\rceil$
    - 通常令 B+ 树的节点与磁盘上的数据块（block）等大，即 4K 字节；令每条记录占据 40 字节，则 n 约为 100
    
    ![在上图的 B+ 树中，n = 4，叶子节点具有 2 或 3 个值](image%206.png)
    
    在上图的 B+ 树中，n = 4，叶子节点具有 2 或 3 个值
    
2. **B+ 树索引的记录查询**
    
    ![image.png](image%207.png)
    
3. **B+ 树索引的记录插入**
    - 若叶子节点被填满，则进行叶子节点的分裂：将叶子节点的前 $\lceil n/2\rceil$ 个元素保留在原来的叶子中，其余的元素移动到新的叶子中；然后插入新的元素，并递归地向上维护
    
    ![image.png](image%208.png)
    
4. **B+ 树索引的记录删除**
    - **Merge Siblings：**若记录删除后，叶子节点的元素个数太少，且它可以与兄弟节点合并，则将该节点和其兄弟节点合并成一个节点，并递归地向上维护
    - **Redistribute Pointers：**若记录删除后，叶子节点的元素个数太少，且它不可以与兄弟节点合并，则将该节点和其兄弟节点的元素进行重新分配，确保两个节点的元素数量都符合最小要求
    - 若执行删除操作后，根节点只剩一个指针，则删除根节点，使其唯一子节点成为新的根节点
    
    ![image.png](image%209.png)
    
5. **B+ 树文件组织 B+ Tree File Organization**
    - 将记录直接放在 B+ 树的叶子节点中，而不是指针
    - 为提高空间利用率（space utilization），在分裂或合并时的重分配（Redistribution）操作中，考虑更多的兄弟节点（这种方法在叶子节点和非叶子节点上均可行）
    - 如果在重分配时考虑到 $m$ 个节点（即 $m-1$ 个兄弟节点），那么每个节点可以确保至少获得 $\lfloor\frac{(m-1)n}{m}\rfloor$ 个项
    
    ![image.png](image%2010.png)
    

### 4. B 树索引

1. **B 树基本知识**
    - 类似于 B+ 树，但 B 树允许 search-key 值只出现一次，从而减少冗余
    - 即：每个 search-key 都包含一个额外的指针字段，如果上层出现了某个 search-key，则它不会在下层重复出现
    
    ![image.png](image%2011.png)
    
2. **优缺点分析**
    - B 树的优点：
        - 由于减少了冗余，因此 B 树的节点数可能更少
        - 一部分 search-key 可以被提前找到，即：在搜索到叶子节点之前就找到搜索对象
    - B 树的缺点：
        - 只有很少的一部分 search-key 可以被提前找到
        - 非叶子节点需要存储更多指针，在节点大小不变的情况下，将导致节点可存储的条目数更少，树的高度增加
        - 操作和实现更加复杂
    - 基于上述比较，B 树在实际中应用较少

## 三、散列索引

### 1. 静态散列 Static Hashing

1. **基本原理**
    - 借助 hash function，search-key 在若干个数据桶之间均匀分布
    - 当 bucket 被填满时，使用 overflow bucket 为其扩展空间
    
    ![image.png](image%2012.png)
    
2. **散列索引的实现**
    
    ![image.png](image%2013.png)
    

### 2. 动态散列 Dynamic Hashing

1. **引入背景**
    - 静态散列的数据桶数目是固定的，在数据规模较小时会造成空间浪费，在数据规模较大时会造成冲突加剧与溢出块增多
    - 在动态散列中，数据桶的数目是动态变化的，适用于大小不断变化的数据库
    - 动态散列的一种实现称为可扩展散列（Extendable Hashing）
2. **可扩展散列 Extendable Hashing**
    - Hash function 产生非常长的一串 Hash 值，通常为 32 位整数
    - 只使用 Hash 值的前 i 位，且初始条件下 i = 0，i 随数据库的大小的变化而变化
    - 需定义一个数据桶地址表，其条目数为 $2^i$；i 的值记录在数据桶地址表中
    - 数据桶地址表中的多条记录可能指向同一个数据桶（即多个数据桶共享相同的 Hash 前缀），因此实际的数据桶数量 $<2^i$
    - 每个数据桶 $j$ 记录一个值 $i_j$，表示所有指向该数据桶的条目具有相同的 Hash 值前 $i_j$ 位
    
    ![image.png](image%2014.png)
    
3. **可扩展散列的记录插入**
    - 先找到该记录对应的数据桶，若数据桶内有空间，直接插入即可；若数据桶内无空间，需对这个数据桶进行分裂（split）
    - 对桶 $j$ 进行分裂
        - 情况一： $i>i_j$ （即：存在多个指针指向桶 $j$）
            - 分配一个新的桶 $z$，令 $i_j$ 和 $i_z$ 等于原 $i_j+1$
            - 调整数据桶地址表的指针，使原来指向 $j$ 的一部分指针指向 $z$
            - 将 $j$ 中原有的条目重新进行散列，填充到 $j$ 或 $z$ 中
            - 插入新的记录，如果对应的数据桶仍然无空间，则递归地执行上述过程
        - 情况二： $i=i_j$ （即：存在唯一指针指向桶 $j$）
            - 将 $i$ 增加 1，并对应地将数据桶地址表的容量翻一倍
            - 调整数据桶地址表的指针，使原表的每个条目与新表的两个条目相对应
            - 此时，一定有 $i>i_j$，转化为情况一处理
    - 当达到某种限制时（如 $i$ 不能再增加），则不再尝试分裂块，而是使用 overflow bucket 为其扩展空间（与静态散列相同），

!!! example

    > **示例：**
    > 
    > 
    > ![image.png](image%2015.png)
    > 
    > ![image.png](image%2016.png)
    > 
    > ![image.png](image%2017.png)
    > 
    > ![image.png](image%2018.png)
    > 

## 四、写优化索引 Write-Optimized Index

1. **LSM 树**
    - 全称：日志结构归并树（Log Structured Merge Tree）
    - 记录插入时，首先进入 Memory 中的 $L_0$ 层级
    - $L_0$ 层级被填满时，将 $L_0$ 层级的所有记录转移到 $L_1$ 层级；通过将 $L_1$ 层级原有的数据与 $L_0$ 层级转入的数据合并，自底向上地构建 B+ 树
    - $L_1$ 层级容量达到阈值时，将 $L_1$ 层级的所有记录转移到 $L_2$ 层级并进行合并，以此类推
    
    ![image.png](image%2019.png)
    
2. **LSM 树的记录操作**
    - 删除操作：通过添加特殊的 “删除” 条目来处理
        - 查找时，如果同时找到原始条目和删除条目，则认为该条目已被删除，不返回其值
        - 合并树时，如果同时找到原始条目和删除条目，则这两个条目将被同时删除
    - 更新操作：先删除，再插入

3. **LSM 树的变体**
    - LSM 树的一种变体称为阶梯式合并（Stepped-merge），允许每个层级存在多棵树
    - 和普通的 LSM 树相比，该变体可以减少写入的开销，但会增加查询开销
4. **LSM 树的优缺点分析**
    - 优点：
        - 插入时，只使用顺序的 I/O 操作，速度更快
        - 叶子是满的，避免空间浪费
        - 和普通的 B+ 树相比，插入每条记录所需的 I/O 数更少
    - 缺点：
        - 查询时，需要搜索多棵树
        - 每一层级的全部内容被拷贝多次